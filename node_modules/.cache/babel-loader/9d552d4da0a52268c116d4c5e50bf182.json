{"remainingRequest":"D:\\IT\\MUIC\\rapid\\customer\\node_modules\\babel-loader\\lib\\index.js!D:\\IT\\MUIC\\rapid\\customer\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!D:\\IT\\MUIC\\rapid\\customer\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\IT\\MUIC\\rapid\\customer\\node_modules\\vue-google-autocomplete\\src\\VueGoogleAutocomplete.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\IT\\MUIC\\rapid\\customer\\node_modules\\vue-google-autocomplete\\src\\VueGoogleAutocomplete.vue","mtime":1522390378000},{"path":"D:\\IT\\MUIC\\rapid\\customer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\IT\\MUIC\\rapid\\customer\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\IT\\MUIC\\rapid\\customer\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\IT\\MUIC\\rapid\\customer\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nvar ADDRESS_COMPONENTS = {\n  street_number: 'short_name',\n  route: 'long_name',\n  locality: 'long_name',\n  administrative_area_level_1: 'short_name',\n  administrative_area_level_2: 'county',\n  country: 'long_name',\n  postal_code: 'short_name'\n};\nvar CITIES_TYPE = ['locality', 'administrative_area_level_3'];\nvar REGIONS_TYPE = ['locality', 'sublocality', 'postal_code', 'country', 'administrative_area_level_1', 'administrative_area_level_2'];\nexport default {\n  name: 'VueGoogleAutocomplete',\n  props: {\n    id: {\n      type: String,\n      required: true\n    },\n    classname: String,\n    placeholder: {\n      type: String,\n      default: 'Start typing'\n    },\n    types: {\n      type: String,\n      default: 'address'\n    },\n    country: {\n      type: [String, Array],\n      default: null\n    },\n    enableGeolocation: {\n      type: Boolean,\n      default: false\n    },\n    geolocationOptions: {\n      type: Object,\n      default: null\n    }\n  },\n  data: function data() {\n    return {\n      /**\n       * The Autocomplete object.\n       *\n       * @type {Autocomplete}\n       * @link https://developers.google.com/maps/documentation/javascript/reference#Autocomplete\n       */\n      autocomplete: null,\n\n      /**\n       * Autocomplete input text\n       * @type {String}\n       */\n      autocompleteText: '',\n      geolocation: {\n        /**\n         * Google Geocoder Objet\n         * @type {Geocoder}\n         * @link https://developers.google.com/maps/documentation/javascript/reference#Geocoder\n         */\n        geocoder: null,\n\n        /**\n         * Filled after geolocate result\n         * @type {Coordinates}\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/Coordinates\n         */\n        loc: null,\n\n        /**\n         * Filled after geolocate result\n         * @type {Position}\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/Position\n         */\n        position: null\n      }\n    };\n  },\n  watch: {\n    autocompleteText: function autocompleteText(newVal, oldVal) {\n      this.$emit('inputChange', {\n        newVal: newVal,\n        oldVal: oldVal\n      }, this.id);\n    },\n    country: function country(newVal, oldVal) {\n      this.autocomplete.setComponentRestrictions({\n        country: this.country === null ? [] : this.country\n      });\n    }\n  },\n  mounted: function mounted() {\n    var options = {};\n\n    if (this.types) {\n      options.types = [this.types];\n    }\n\n    if (this.country) {\n      options.componentRestrictions = {\n        country: this.country\n      };\n    }\n\n    this.autocomplete = new google.maps.places.Autocomplete(document.getElementById(this.id), options);\n    this.autocomplete.addListener('place_changed', this.onPlaceChanged);\n  },\n  methods: {\n    /**\n     * When a place changed\n     */\n    onPlaceChanged: function onPlaceChanged() {\n      var place = this.autocomplete.getPlace();\n\n      if (!place.geometry) {\n        // User entered the name of a Place that was not suggested and\n        // pressed the Enter key, or the Place Details request failed.\n        this.$emit('no-results-found', place, this.id);\n        return;\n      }\n\n      if (place.address_components !== undefined) {\n        // return returnData object and PlaceResult object\n        this.$emit('placechanged', this.formatResult(place), place, this.id); // update autocompleteText then emit change event\n\n        this.autocompleteText = document.getElementById(this.id).value;\n        this.onChange();\n      }\n    },\n\n    /**\n     * When the input gets focus\n     */\n    onFocus: function onFocus() {\n      this.biasAutocompleteLocation();\n      this.$emit('focus');\n    },\n\n    /**\n     * When the input loses focus\n     */\n    onBlur: function onBlur() {\n      this.$emit('blur');\n    },\n\n    /**\n     * When the input got changed\n     */\n    onChange: function onChange() {\n      this.$emit('change', this.autocompleteText);\n    },\n\n    /**\n     * When a key gets pressed\n     * @param  {Event} event A keypress event\n     */\n    onKeyPress: function onKeyPress(event) {\n      this.$emit('keypress', event);\n    },\n\n    /**\n     * When a keyup occurs\n     * @param  {Event} event A keyup event\n     */\n    onKeyUp: function onKeyUp(event) {\n      this.$emit('keyup', event);\n    },\n\n    /**\n     * Clear the input\n     */\n    clear: function clear() {\n      this.autocompleteText = '';\n    },\n\n    /**\n     * Focus the input\n     */\n    focus: function focus() {\n      this.$refs.autocomplete.focus();\n    },\n\n    /**\n     * Blur the input\n     */\n    blur: function blur() {\n      this.$refs.autocomplete.blur();\n    },\n\n    /**\n     * Update the value of the input\n     * @param  {String} value\n     */\n    update: function update(value) {\n      this.autocompleteText = value;\n    },\n\n    /**\n     * Update the coordinates of the input\n     * @param  {Coordinates} value\n     */\n    updateCoordinates: function updateCoordinates(value) {\n      var _this = this;\n\n      if (!value && !(value.lat || value.lng)) return;\n      if (!this.geolocation.geocoder) this.geolocation.geocoder = new google.maps.Geocoder();\n      this.geolocation.geocoder.geocode({\n        'location': value\n      }, function (results, status) {\n        if (status === 'OK') {\n          results = _this.filterGeocodeResultTypes(results);\n\n          if (results[0]) {\n            _this.$emit('placechanged', _this.formatResult(results[0]), results[0], _this.id);\n\n            _this.update(results[0].formatted_address);\n          } else {\n            _this.$emit('error', 'no result for provided coordinates');\n          }\n        } else {\n          _this.$emit('error', 'error getting address from coords');\n        }\n      });\n    },\n\n    /**\n     * Update location based on navigator geolocation\n     */\n    geolocate: function geolocate() {\n      var _this2 = this;\n\n      this.updateGeolocation(function (geolocation, position) {\n        _this2.updateCoordinates(geolocation);\n      });\n    },\n\n    /**\n     * Update internal location from navigator geolocation\n     * @param  {Function} (geolocation, position)\n     */\n    updateGeolocation: function updateGeolocation() {\n      var _this3 = this;\n\n      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (navigator.geolocation) {\n        var options = {};\n        if (this.geolocationOptions) Object.assign(options, this.geolocationOptions);\n        navigator.geolocation.getCurrentPosition(function (position) {\n          var geolocation = {\n            lat: position.coords.latitude,\n            lng: position.coords.longitude\n          };\n          _this3.geolocation.loc = geolocation;\n          _this3.geolocation.position = position;\n          if (callback) callback(geolocation, position);\n        }, function (err) {\n          _this3.$emit('error', 'Cannot get Coordinates from navigator', err);\n        }, options);\n      }\n    },\n    // Bias the autocomplete object to the user's geographical location,\n    // as supplied by the browser's 'navigator.geolocation' object.\n    biasAutocompleteLocation: function biasAutocompleteLocation() {\n      var _this4 = this;\n\n      if (this.enableGeolocation) {\n        this.updateGeolocation(function (geolocation, position) {\n          var circle = new google.maps.Circle({\n            center: geolocation,\n            radius: position.coords.accuracy\n          });\n\n          _this4.autocomplete.setBounds(circle.getBounds());\n        });\n      }\n    },\n\n    /**\n     * Format result from Geo google APIs\n     * @param place\n     * @returns {{formatted output}}\n     */\n    formatResult: function formatResult(place) {\n      var returnData = {};\n\n      for (var i = 0; i < place.address_components.length; i++) {\n        var addressType = place.address_components[i].types[0];\n\n        if (ADDRESS_COMPONENTS[addressType]) {\n          var val = place.address_components[i][ADDRESS_COMPONENTS[addressType]];\n          returnData[addressType] = val;\n        }\n      }\n\n      returnData['latitude'] = place.geometry.location.lat();\n      returnData['longitude'] = place.geometry.location.lng();\n      return returnData;\n    },\n\n    /**\n     * Extract configured types out of raw result as\n     * Geocode API does not allow to do it\n     * @param results\n     * @returns {GeocoderResult}\n     * @link https://developers.google.com/maps/documentation/javascript/reference#GeocoderResult\n     */\n    filterGeocodeResultTypes: function filterGeocodeResultTypes(results) {\n      if (!results || !this.types) return results;\n      var output = [];\n      var types = [this.types];\n      if (types.includes('(cities)')) types = types.concat(CITIES_TYPE);\n      if (types.includes('(regions)')) types = types.concat(REGIONS_TYPE);\n\n      var _iterator = _createForOfIteratorHelper(results),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var r = _step.value;\n\n          var _iterator2 = _createForOfIteratorHelper(r.types),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var t = _step2.value;\n\n              if (types.includes(t)) {\n                output.push(r);\n                break;\n              }\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return output;\n    }\n  }\n};",{"version":3,"sources":["VueGoogleAutocomplete.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n    <input\n        ref=\"autocomplete\"\n        type=\"text\"\n        :class=\"classname\"\n        :id=\"id\"\n        :placeholder=\"placeholder\"\n        v-model=\"autocompleteText\"\n        @focus=\"onFocus()\"\n        @blur=\"onBlur()\"\n        @change=\"onChange\"\n        @keypress=\"onKeyPress\"\n        @keyup=\"onKeyUp\"\n    />\n</template>\n\n<script>\n    const ADDRESS_COMPONENTS = {\n        street_number: 'short_name',\n        route: 'long_name',\n        locality: 'long_name',\n        administrative_area_level_1: 'short_name',\n        administrative_area_level_2: 'county',\n        country: 'long_name',\n        postal_code: 'short_name'\n    };\n\n    const CITIES_TYPE = ['locality', 'administrative_area_level_3'];\n    const REGIONS_TYPE = ['locality', 'sublocality', 'postal_code', 'country',\n        'administrative_area_level_1', 'administrative_area_level_2'];\n\n    export default {\n        name: 'VueGoogleAutocomplete',\n\n        props: {\n          id: {\n            type: String,\n            required: true\n          },\n\n          classname: String,\n\n          placeholder: {\n            type: String,\n            default: 'Start typing'\n          },\n\n          types: {\n            type: String,\n            default: 'address'\n          },\n\n          country: {\n            type: [String, Array],\n            default: null\n          },\n\n          enableGeolocation: {\n            type: Boolean,\n            default: false\n          },\n\n          geolocationOptions: {\n            type: Object,\n            default: null\n          }\n        },\n\n        data() {\n            return {\n                /**\n                 * The Autocomplete object.\n                 *\n                 * @type {Autocomplete}\n                 * @link https://developers.google.com/maps/documentation/javascript/reference#Autocomplete\n                 */\n                autocomplete: null,\n\n                /**\n                 * Autocomplete input text\n                 * @type {String}\n                 */\n                autocompleteText: '',\n\n                geolocation: {\n                    /**\n                     * Google Geocoder Objet\n                     * @type {Geocoder}\n                     * @link https://developers.google.com/maps/documentation/javascript/reference#Geocoder\n                     */\n                    geocoder: null,\n\n                    /**\n                     * Filled after geolocate result\n                     * @type {Coordinates}\n                     * @link https://developer.mozilla.org/en-US/docs/Web/API/Coordinates\n                     */\n                    loc: null,\n\n                    /**\n                     * Filled after geolocate result\n                     * @type {Position}\n                     * @link https://developer.mozilla.org/en-US/docs/Web/API/Position\n                     */\n                    position: null\n                }\n            }\n        },\n\n        watch: {\n            autocompleteText: function (newVal, oldVal) {\n\t            this.$emit('inputChange', { newVal, oldVal }, this.id);\n            },\n            country: function(newVal, oldVal) {\n              this.autocomplete.setComponentRestrictions({\n                country: this.country === null ? [] : this.country\n              });\n            }\n        },\n\n        mounted: function() {\n          const options = {};\n\n          if (this.types) {\n            options.types = [this.types];\n          }\n\n          if (this.country) {\n            options.componentRestrictions = {\n              country: this.country\n            };\n          }\n\n          this.autocomplete = new google.maps.places.Autocomplete(\n                document.getElementById(this.id),\n                options\n            );\n\n          this.autocomplete.addListener('place_changed', this.onPlaceChanged);\n        },\n\n        methods: {\n            /**\n             * When a place changed\n             */\n            onPlaceChanged() {\n                let place = this.autocomplete.getPlace();\n\n                if (!place.geometry) {\n                  // User entered the name of a Place that was not suggested and\n                  // pressed the Enter key, or the Place Details request failed.\n                  this.$emit('no-results-found', place, this.id);\n                  return;\n                }\n\n                if (place.address_components !== undefined) {\n                    // return returnData object and PlaceResult object\n                    this.$emit('placechanged', this.formatResult(place), place, this.id);\n\n                    // update autocompleteText then emit change event\n                    this.autocompleteText = document.getElementById(this.id).value\n                    this.onChange()\n                }\n            },\n\n            /**\n             * When the input gets focus\n             */\n            onFocus() {\n              this.biasAutocompleteLocation();\n              this.$emit('focus');\n            },\n\n            /**\n             * When the input loses focus\n             */\n            onBlur() {\n              this.$emit('blur');\n            },\n\n            /**\n             * When the input got changed\n             */\n            onChange() {\n              this.$emit('change', this.autocompleteText);\n            },\n\n            /**\n             * When a key gets pressed\n             * @param  {Event} event A keypress event\n             */\n            onKeyPress(event) {\n              this.$emit('keypress', event);\n            },\n\n            /**\n             * When a keyup occurs\n             * @param  {Event} event A keyup event\n             */\n            onKeyUp(event) {\n              this.$emit('keyup', event);\n            },\n\n            /**\n             * Clear the input\n             */\n            clear() {\n              this.autocompleteText = ''\n            },\n\n            /**\n             * Focus the input\n             */\n            focus() {\n              this.$refs.autocomplete.focus()\n            },\n\n            /**\n             * Blur the input\n             */\n            blur() {\n              this.$refs.autocomplete.blur()\n            },\n\n            /**\n             * Update the value of the input\n             * @param  {String} value\n             */\n            update (value) {\n              this.autocompleteText = value\n            },\n\n            /**\n             * Update the coordinates of the input\n             * @param  {Coordinates} value\n             */\n            updateCoordinates (value) {\n                if (!value && !(value.lat || value.lng)) return;\n                if (!this.geolocation.geocoder) this.geolocation.geocoder = new google.maps.Geocoder();\n                this.geolocation.geocoder.geocode({'location': value}, (results, status) => {\n                    if (status === 'OK') {\n                        results = this.filterGeocodeResultTypes(results);\n                        if (results[0]) {\n                            this.$emit('placechanged', this.formatResult(results[0]), results[0], this.id);\n                            this.update(results[0].formatted_address);\n                        } else {\n                            this.$emit('error', 'no result for provided coordinates');\n                        }\n                    } else {\n                        this.$emit('error', 'error getting address from coords');\n                    }\n                })\n            },\n\n            /**\n             * Update location based on navigator geolocation\n             */\n            geolocate () {\n                this.updateGeolocation ((geolocation, position) => {\n                    this.updateCoordinates(geolocation)\n                })\n            },\n\n            /**\n             * Update internal location from navigator geolocation\n             * @param  {Function} (geolocation, position)\n             */\n            updateGeolocation (callback = null) {\n                if (navigator.geolocation) {\n                    let options = {};\n                    if(this.geolocationOptions) Object.assign(options, this.geolocationOptions);\n                    navigator.geolocation.getCurrentPosition(position => {\n                        let geolocation = {\n                            lat: position.coords.latitude,\n                            lng: position.coords.longitude\n                        };\n                        this.geolocation.loc = geolocation;\n                        this.geolocation.position = position;\n\n                        if (callback) callback(geolocation, position);\n                    }, err => {\n                        this.$emit('error', 'Cannot get Coordinates from navigator', err);\n                    }, options);\n                }\n            },\n\n\n            // Bias the autocomplete object to the user's geographical location,\n            // as supplied by the browser's 'navigator.geolocation' object.\n            biasAutocompleteLocation () {\n                if (this.enableGeolocation) {\n                    this.updateGeolocation((geolocation, position) => {\n                        let circle = new google.maps.Circle({\n                            center: geolocation,\n                            radius: position.coords.accuracy\n                        });\n                        this.autocomplete.setBounds(circle.getBounds());\n                    })\n                }\n            },\n\n            /**\n             * Format result from Geo google APIs\n             * @param place\n             * @returns {{formatted output}}\n             */\n            formatResult (place) {\n                let returnData = {};\n                for (let i = 0; i < place.address_components.length; i++) {\n                    let addressType = place.address_components[i].types[0];\n\n                    if (ADDRESS_COMPONENTS[addressType]) {\n                        let val = place.address_components[i][ADDRESS_COMPONENTS[addressType]];\n                        returnData[addressType] = val;\n                    }\n                }\n\n                returnData['latitude'] = place.geometry.location.lat();\n                returnData['longitude'] = place.geometry.location.lng();\n                return returnData\n            },\n\n            /**\n             * Extract configured types out of raw result as\n             * Geocode API does not allow to do it\n             * @param results\n             * @returns {GeocoderResult}\n             * @link https://developers.google.com/maps/documentation/javascript/reference#GeocoderResult\n             */\n            filterGeocodeResultTypes (results) {\n                if (!results || !this.types) return results;\n                let output = [];\n                let types = [this.types];\n                if (types.includes('(cities)')) types = types.concat(CITIES_TYPE);\n                if (types.includes('(regions)')) types = types.concat(REGIONS_TYPE);\n\n                for (let r of results) {\n                    for (let t of r.types) {\n                        if (types.includes(t)) {\n                            output.push(r);\n                            break;\n                        }\n                    }\n                }\n                return output;\n            }\n        }\n    }\n</script>\n"],"sourceRoot":"node_modules/vue-google-autocomplete/src"}]}
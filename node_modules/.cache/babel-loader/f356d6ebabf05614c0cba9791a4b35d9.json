{"remainingRequest":"D:\\IT\\MUIC\\rapid\\Todo rael\\node_modules\\babel-loader\\lib\\index.js!D:\\IT\\MUIC\\rapid\\Todo rael\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!D:\\IT\\MUIC\\rapid\\Todo rael\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!D:\\IT\\MUIC\\rapid\\Todo rael\\node_modules\\vue-place-autocomplete\\src\\PlaceAutocompleteField.vue?vue&type=script&lang=js&","dependencies":[{"path":"D:\\IT\\MUIC\\rapid\\Todo rael\\node_modules\\vue-place-autocomplete\\src\\PlaceAutocompleteField.vue","mtime":499162500000},{"path":"D:\\IT\\MUIC\\rapid\\Todo rael\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\IT\\MUIC\\rapid\\Todo rael\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\IT\\MUIC\\rapid\\Todo rael\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\IT\\MUIC\\rapid\\Todo rael\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.regexp.search\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport geocode from \"./Helpers/Geocode\";\nimport script from 'vue-interface/src/Helpers/Script';\nimport PlaceAutocompleteList from \"./PlaceAutocompleteList\";\nimport FormControl from 'vue-interface/src/Mixins/FormControl';\nimport FormGroup from 'vue-interface/src/Components/FormGroup';\nimport InputField from 'vue-interface/src/Components/InputField';\nimport ActivityIndicator from 'vue-interface/src/Components/ActivityIndicator';\nvar KEYCODE = {\n  ESC: 27,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40,\n  ENTER: 13,\n  SPACE: 32,\n  TAB: 9\n};\nvar API_REQUEST_OPTIONS = ['bounds', 'location', 'component-restrictions', 'offset', 'radius', 'types'];\nexport default {\n  name: 'place-autocomplete-field',\n  mixins: [FormControl],\n  components: {\n    FormGroup: FormGroup,\n    InputField: InputField,\n    ActivityIndicator: ActivityIndicator,\n    PlaceAutocompleteList: PlaceAutocompleteList\n  },\n  watch: {\n    value: function value(_value) {\n      this.query = _value;\n    }\n  },\n  props: {\n    apiKey: String,\n    baseUri: {\n      type: String,\n      default: 'https://maps.googleapis.com/maps/api/js'\n    },\n    componentRestrictions: {\n      type: [Boolean, Object, String],\n      default: false\n    },\n    custom: Boolean,\n    libraries: {\n      type: Array,\n      default: function _default() {\n        return ['geometry', 'places'];\n      }\n    },\n    bounds: {\n      type: [Boolean, Object, String],\n      default: false\n    },\n    location: {\n      type: [Boolean, Object, String],\n      default: false\n    },\n    offset: {\n      type: Boolean,\n      default: false\n    },\n    radius: {\n      type: Boolean,\n      default: false\n    },\n    types: {\n      type: [Boolean, Array],\n      default: false\n    }\n  },\n  methods: {\n    getInputElement: function getInputElement() {\n      return this.$el.querySelector('input');\n    },\n    getRequestOptions: function getRequestOptions() {\n      var options = {\n        input: this.getInputElement().value\n      };\n\n      for (var i in API_REQUEST_OPTIONS) {\n        if (this[i] !== undefined || this[i] !== null) {\n          options[i] = this[i];\n        }\n      }\n\n      return options;\n    },\n    select: function select(place) {\n      var _this = this;\n\n      geocode({\n        placeId: place.place_id\n      }).then(function (response) {\n        //this.hide();\n        _this.$emit('input', _this.query = response[0].formatted_address);\n\n        _this.$emit('autocomplete-select', place, response[0]);\n      });\n    },\n    search: function search() {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (!_this2.getInputElement().value) {\n          _this2.predictions = false;\n          _this2.showPredictions = false; // reject(new Error('Input empty'));\n        } else {\n          _this2.showActivityIndicator = true;\n\n          _this2.$service.getPlacePredictions(_this2.getRequestOptions(), function (response, status) {\n            _this2.showActivityIndicator = false;\n\n            switch (status) {\n              case window.google.maps.places.PlacesServiceStatus.OK:\n                resolve(response);\n                break;\n\n              default:\n                reject(new Error(\"Error with status: \".concat(status)));\n            }\n          });\n        }\n      });\n    },\n    hide: function hide() {\n      this.showPredictions = false;\n    },\n    show: function show() {\n      this.showPredictions = true;\n    },\n    up: function up() {\n      var focused = this.$el.querySelector('a:focus');\n\n      if (focused && focused.parentElement.previousElementSibling) {\n        focused.parentElement.previousElementSibling.querySelector('a').focus();\n      } else {\n        var links = this.$el.querySelectorAll('a');\n        links[links.length - 1].focus();\n      }\n    },\n    down: function down() {\n      var focused = this.$el.querySelector('a:focus');\n\n      if (focused && focused.parentElement.nextElementSibling) {\n        focused.parentElement.nextElementSibling.querySelector('a').focus();\n      } else {\n        this.$el.querySelector('a').focus();\n      }\n    },\n    onKeydown: function onKeydown(event) {\n      var element = this.$el.querySelector('[tabindex]');\n\n      if (element && event.keyCode === KEYCODE.TAB) {\n        event.preventDefault() && element.focus();\n      }\n    },\n    onKeyup: function onKeyup(event) {\n      var _this3 = this;\n\n      switch (event.keyCode) {\n        case KEYCODE.ENTER:\n        case KEYCODE.SPACE:\n          if (this.$el.querySelector('.is-focused')) {\n            this.$el.querySelector('.is-focused a').dispatchEvent(new Event('mousedown'));\n          }\n\n          return;\n\n        case KEYCODE.ESC:\n          this.hide();\n          this.getInputElement().blur();\n          return;\n\n        case KEYCODE.UP:\n          this.up();\n          event.preventDefault();\n          return;\n\n        case KEYCODE.DOWN:\n          this.down();\n          event.preventDefault();\n          return;\n      }\n\n      this.search().then(function (response) {\n        _this3.predictions = response;\n        _this3.showPredictions = true;\n      }, function (error) {\n        if (error) {\n          _this3.predictions = false;\n        }\n      });\n    },\n    onFocus: function onFocus(event) {\n      if (this.query) {\n        if (!this.predictions.length) {\n          this.onKeyup(event);\n        }\n\n        this.show();\n      }\n    },\n    onBlur: function onBlur(event) {\n      if (!this.$el.contains(event.relatedTarget)) {\n        this.hide();\n      }\n    },\n    onItemBlur: function onItemBlur(event) {\n      this.onBlur(event);\n    },\n    onItemClick: function onItemClick(event, child) {\n      this.select(child.item);\n      this.predictions = false;\n    }\n  },\n  mounted: function mounted() {\n    var _this4 = this;\n\n    if (this.apiKey) {\n      script(\"\".concat(this.baseUri, \"?key=\").concat(this.apiKey, \"&libraries=\").concat(this.libraries.join(','))).then(function () {\n        _this4.$geocoder = new window.google.maps.Geocoder();\n        _this4.$service = new window.google.maps.places.AutocompleteService();\n        _this4.loaded = true;\n\n        _this4.$emit('loaded');\n      });\n    }\n  },\n  data: function data() {\n    return {\n      loaded: false,\n      predictions: false,\n      query: this.value,\n      showPredictions: false,\n      showActivityIndicator: this.activity\n    };\n  }\n  /*\n  {\n      // An array of types specifies an explicit type or a type collection, as listed in the supported types below. If nothing is specified, all types are returned. In general only a single type is allowed. The exception is that you can safely mix the geocode and establishment types, but note that this will have the same effect as specifying no types. The supported types are: geocode instructs the Places service to return only geocoding results, rather than business results. address instructs the Places service to return only geocoding results with a precise address. establishment instructs the Places service to return only business results. the (regions) type collection instructs the Places service to return any result matching the following types: locality sublocality postal_code country administrative_area1 administrative_area2 the (cities) type collection instructs the Places service to return results that match either locality or administrative_area3.\n      // Possible values: geocode, address, establishment, cities, locality, sublocality, postal_code, country, administrative_area1, administrative_area2\n      type: undefined,\n       // is a google.maps.LatLngBounds|google.maps.LatLngBoundsLiteral object specifying the area in which to search for places. The results are biased towards, but not restricted to, places contained within these bounds.\n      bounds: undefined,\n       // is a boolean specifying whether the API must return only those places that are strictly within the region defined by the given bounds. The API does not return results outside this region even if they match the user input.\n      strictBounds: true|false,\n       // can be used to restrict results to specific groups. Currently, you can use componentRestrictions to filter by up to 5 countries. Countries must be passed as as a two-character, ISO 3166-1 Alpha-2 compatible country code. Multiple countries must be passed as a list of country codes. z\n      componentRestrictions: undefined,\n       // can be used to instruct the Autocomplete widget to retrieve only Place IDs. On calling getPlace() on the Autocomplete object, the PlaceResult made available will only have the place id, types and name properties set. You can use the returned place ID with calls to the Places, Geocoding, Directions or Distance Matrix services.\n      placeIdOnly: undefined,\n       // is a google.maps.LatLng for prediction biasing. Predictions will be biased towards the given location and radius. Alternatively, bounds can be used.\n      location: undefined,\n       // is a number to determine the character position in the input term at which the service uses text for predictions (the position of the cursor in the input field).\n      offset: undefined,\n       // is a number to the radius of the area used for prediction biasing. The radius is specified in meters, and must always be accompanied by a location property. Alternatively, bounds can be used.\n      radius: undefined\n  }\n  */\n\n};",{"version":3,"sources":["PlaceAutocompleteField.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n    <div class=\"autocomplete-field\" @keydown=\"onKeydown\" @keyup=\"onKeyup\">\n        <input-field\n            v-model=\"query\"\n            v-bind-events\n            v-bind=\"$attrs\"\n            :label=\"label\"\n            :errors=\"errors\"\n            :value=\"value\"\n            :custom=\"custom\"\n            autocomplete=\"no\"\n            @blur=\"onBlur\"\n            @focus=\"onFocus\"\n            @input=\"$emit('input', query)\">\n            <activity-indicator v-if=\"showActivityIndicator\" size=\"xs\" type=\"spinner\"/>\n        </input-field>\n        <place-autocomplete-list v-if=\"predictions && showPredictions\" :items=\"predictions\" @item:click=\"onItemClick\" @item:blur=\"onItemBlur\"/>\n    </div>\n</template>\n\n<script>\nimport geocode from './Helpers/Geocode';\nimport script from 'vue-interface/src/Helpers/Script';\nimport PlaceAutocompleteList from './PlaceAutocompleteList';\nimport FormControl from 'vue-interface/src/Mixins/FormControl';\nimport FormGroup from 'vue-interface/src/Components/FormGroup';\nimport InputField from 'vue-interface/src/Components/InputField';\nimport ActivityIndicator from 'vue-interface/src/Components/ActivityIndicator';\n\nconst KEYCODE = {\n    ESC: 27,\n    LEFT: 37,\n    UP: 38,\n    RIGHT: 39,\n    DOWN: 40,\n    ENTER: 13,\n    SPACE: 32,\n    TAB: 9\n};\n\nconst API_REQUEST_OPTIONS = [\n    'bounds',\n    'location',\n    'component-restrictions',\n    'offset',\n    'radius',\n    'types'\n];\n\nexport default {\n\n    name: 'place-autocomplete-field',\n\n    mixins: [\n        FormControl\n    ],\n\n    components: {\n        FormGroup,\n        InputField,\n        ActivityIndicator,\n        PlaceAutocompleteList\n    },\n\n    watch: {\n        value(value) {\n            this.query = value;\n        }\n    },\n\n    props: {\n\n        apiKey: String,\n\n        baseUri: {\n            type: String,\n            default: 'https://maps.googleapis.com/maps/api/js'\n        },\n\n        componentRestrictions: {\n            type: [Boolean, Object, String],\n            default: false\n        },\n\n        custom: Boolean,\n\n        libraries: {\n            type: Array,\n            default() {\n                return ['geometry', 'places'];\n            }\n        },\n\n        bounds: {\n            type: [Boolean, Object, String],\n            default: false\n        },\n\n        location: {\n            type: [Boolean, Object, String],\n            default: false\n        },\n\n        offset: {\n            type: Boolean,\n            default: false\n        },\n\n        radius: {\n            type: Boolean,\n            default: false\n        },\n\n        types: {\n            type: [Boolean, Array],\n            default: false\n        }\n\n    },\n\n    methods: {\n\n        getInputElement() {\n            return this.$el.querySelector('input');\n        },\n\n        getRequestOptions() {\n            const options = {\n                input: this.getInputElement().value\n            };\n\n            for (let i in API_REQUEST_OPTIONS) {\n                if (this[i] !== undefined || this[i] !== null) {\n                    options[i] = this[i];\n                }\n            }\n\n            return options;\n        },\n\n        select(place) {\n            geocode({ placeId: place.place_id }).then(response => {\n                //this.hide();\n                this.$emit('input', this.query = response[0].formatted_address);\n                this.$emit('autocomplete-select', place, response[0]);\n            });\n        },\n\n        search() {\n            return new Promise((resolve, reject) => {\n                if (!this.getInputElement().value) {\n                    this.predictions = false;\n                    this.showPredictions = false;\n                    // reject(new Error('Input empty'));\n                }\n                else {\n                    this.showActivityIndicator = true;\n\n                    this.$service.getPlacePredictions(this.getRequestOptions(), (response, status) => {\n                        this.showActivityIndicator = false;\n\n                        switch (status) {\n                        case window.google.maps.places.PlacesServiceStatus.OK:\n                            resolve(response);\n                            break;\n                        default:\n                            reject(new Error(`Error with status: ${status}`));\n                        }\n                    });\n                }\n            });\n        },\n\n        hide() {\n            this.showPredictions = false;\n        },\n\n        show() {\n            this.showPredictions = true;\n        },\n\n        up() {\n            const focused = this.$el.querySelector('a:focus');\n\n            if (focused && focused.parentElement.previousElementSibling) {\n                focused.parentElement.previousElementSibling.querySelector('a').focus();\n            }\n            else {\n                const links = this.$el.querySelectorAll('a');\n                links[links.length - 1].focus();\n            }\n        },\n\n        down() {\n            const focused = this.$el.querySelector('a:focus');\n\n            if (focused && focused.parentElement.nextElementSibling) {\n                focused.parentElement.nextElementSibling.querySelector('a').focus();\n            }\n            else {\n                this.$el.querySelector('a').focus();\n            }\n        },\n\n        onKeydown(event) {\n            const element = this.$el.querySelector('[tabindex]');\n\n            if (element && event.keyCode === KEYCODE.TAB) {\n                event.preventDefault() && element.focus();\n            }\n        },\n\n        onKeyup(event) {\n            switch (event.keyCode) {\n            case KEYCODE.ENTER:\n            case KEYCODE.SPACE:\n                if (this.$el.querySelector('.is-focused')) {\n                    this.$el.querySelector('.is-focused a').dispatchEvent(new Event('mousedown'));\n                }\n                return;\n            case KEYCODE.ESC:\n                this.hide();\n                this.getInputElement().blur();\n                return;\n            case KEYCODE.UP:\n                this.up();\n                event.preventDefault();\n                return;\n            case KEYCODE.DOWN:\n                this.down();\n                event.preventDefault();\n                return;\n            }\n\n            this.search().then(response => {\n                this.predictions = response;\n                this.showPredictions = true;\n            }, error => {\n                if (error) {\n                    this.predictions = false;\n                }\n            });\n        },\n\n        onFocus(event) {\n            if (this.query) {\n                if (!this.predictions.length) {\n                    this.onKeyup(event);\n                }\n\n                this.show();\n            }\n        },\n\n        onBlur(event) {\n            if (!this.$el.contains(event.relatedTarget)) {\n                this.hide();\n            }\n        },\n\n        onItemBlur(event) {\n            this.onBlur(event);\n        },\n\n        onItemClick(event, child) {\n            this.select(child.item);\n            this.predictions = false;\n        }\n\n    },\n\n    mounted() {\n        if(this.apiKey) {\n            script(`${this.baseUri}?key=${this.apiKey}&libraries=${this.libraries.join(',')}`).then(() => {\n                this.$geocoder = new window.google.maps.Geocoder();\n                this.$service = new window.google.maps.places.AutocompleteService();\n                this.loaded = true;\n                this.$emit('loaded');\n            });\n        }\n    },\n\n    data() {\n        return {\n            loaded: false,\n            predictions: false,\n            query: this.value,\n            showPredictions: false,\n            showActivityIndicator: this.activity\n        };\n    }\n\n    /*\n    {\n        // An array of types specifies an explicit type or a type collection, as listed in the supported types below. If nothing is specified, all types are returned. In general only a single type is allowed. The exception is that you can safely mix the geocode and establishment types, but note that this will have the same effect as specifying no types. The supported types are: geocode instructs the Places service to return only geocoding results, rather than business results. address instructs the Places service to return only geocoding results with a precise address. establishment instructs the Places service to return only business results. the (regions) type collection instructs the Places service to return any result matching the following types: locality sublocality postal_code country administrative_area1 administrative_area2 the (cities) type collection instructs the Places service to return results that match either locality or administrative_area3.\n        // Possible values: geocode, address, establishment, cities, locality, sublocality, postal_code, country, administrative_area1, administrative_area2\n        type: undefined,\n\n        // is a google.maps.LatLngBounds|google.maps.LatLngBoundsLiteral object specifying the area in which to search for places. The results are biased towards, but not restricted to, places contained within these bounds.\n        bounds: undefined,\n\n        // is a boolean specifying whether the API must return only those places that are strictly within the region defined by the given bounds. The API does not return results outside this region even if they match the user input.\n        strictBounds: true|false,\n\n        // can be used to restrict results to specific groups. Currently, you can use componentRestrictions to filter by up to 5 countries. Countries must be passed as as a two-character, ISO 3166-1 Alpha-2 compatible country code. Multiple countries must be passed as a list of country codes. z\n        componentRestrictions: undefined,\n\n        // can be used to instruct the Autocomplete widget to retrieve only Place IDs. On calling getPlace() on the Autocomplete object, the PlaceResult made available will only have the place id, types and name properties set. You can use the returned place ID with calls to the Places, Geocoding, Directions or Distance Matrix services.\n        placeIdOnly: undefined,\n\n        // is a google.maps.LatLng for prediction biasing. Predictions will be biased towards the given location and radius. Alternatively, bounds can be used.\n        location: undefined,\n\n        // is a number to determine the character position in the input term at which the service uses text for predictions (the position of the cursor in the input field).\n        offset: undefined,\n\n        // is a number to the radius of the area used for prediction biasing. The radius is specified in meters, and must always be accompanied by a location property. Alternatively, bounds can be used.\n        radius: undefined\n    }\n    */\n};\n</script>\n\n<style lang=\"scss\">\n.autocomplete-field {\n    position: relative;\n\n    .activity-indicator {\n        right: .5rem;\n        bottom: .5rem;\n        position: absolute;\n    }\n}\n\n.autocomplete-list-wrapper {\n    position: absolute;\n    z-index: 10;\n    width: 100%;\n    top: 100%;\n    background: white;\n}\n\n.autocomplete-list {\n    margin: 0;\n    padding: 0;\n    box-shadow: 0 0 10px rgba(0, 0, 0, .25);\n}\n</style>\n"],"sourceRoot":"node_modules/vue-place-autocomplete/src"}]}